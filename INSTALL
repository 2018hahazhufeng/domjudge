DOMjudge INSTALLATION INSTRUCTIONS
==================================


SYSTEM REQUIREMENTS
-------------------

This judging system was developed and tested on GNU/Linux systems,
specifically on Debian Woody and RedHat 9. We have tried to use 
standard UNIX utilities and libraries, so this system should be
reasonably portable to other Unix systems, but we have not done any
tests, so nothing guaranteed...

For the deployment of this jury-system, there are some requirements:

- A TCP/IP network which connects all jury and team computers.
  Extra network security which restricts internet access and access to
  other services (ssh, mail, talk, etc..) is advisable, but not
  provided by this software.

TODO: list of necessary protocols between different parts of the system.

- One jury account with a homedirectory which is shared between all
  jury-computers (e.g. via NFS).
  
- Team accounts which are accessible via SSH on the jurycomputers
  (a SSH public key of the jury account should be installed on all team
   accounts to provide public-key access).

- (Local) root access on the jury-computers (preferably also on the
  shared homedirectory) for (un)mounting proc and installing some
  programs setuid-root.


SOFTWARE REQUIREMENTS
---------------------

- gcc with standard libraries

- make

- For every supported programming language a compiler is needed,
  which can generate statically linked standalone executables.

- A webserver which supports PHP >= 4.1.0

- MySQL 3.23.x or higher database and client software

- PHP >= 4.1.0, located in /usr/bin/php (command line interface)

- Bash 2, located in /bin/bash

- Statically compiled Bash 2 (included for Linux IA32)

- glibc 2.1 or higher

- A lot of standard (GNU) programs, a probably incomplete list:
	hostname, date, dirname, basename, touch, chmod, cp, mv, cat,
	grep, diff, wc, mkdir, mkfifo, mount, sleep, head, tail

- sudo

- OpenSSH/SCP (or a compatible ssh/scp client/daemon)


FILE LOCATIONS
--------------

There are three different directory trees which must be set up and
configured, before the beginning of a contest. The root paths of these
directory trees should be set in the main config file. (Directories in
uppercase are configuration variables, which can be set to different
locations (even within different roots, although not tested!)).

SYSTEM_ROOT
	The judging system itself is contained in this directory tree. All
	programs needed for the judging system are located here alongside
	some extra utilities and the configuration of the system.

INPUT_ROOT
	The problem input and output testdata should be put here. This
	directory-tree is for input only, so (in principle) this directory
	tree can be read-only.

	Each problem should have its own directory within INPUT_ROOT,
	where input and output testdata have to be placed.

OUTPUT_ROOT
	Placed here are all submission files, logfiles and temporary
	files, made while testing submissions. The following directories
	should be present within OUTPUT_ROOT:

	LOGDIR        contains all logfiles.
	INCOMINGDIR   contains submission files, being submitted or where
	              a submission error has occurred.
	SUBMITDIR     contains all correctly submitted files.
	JUDGEDIR      place where submissions are tested, each in its own
	              subdirectory. The system needs root access to this
	              directory! (for chroot and mounting of proc-fs).


CONFIGURATION
-------------

Configuration of the judge system is mostly done by editing the
global configuration file in SYSTEM_ROOT/etc/global.cfg. This file
contains the configuration data for all programs within the
system. To implement configuration changes, these settings should be
converted to the different language-specific configuration-files,
needed by different parts of the system. This is done by running the
command 'generate_config.sh' in the configuration directory. After
that, also all C/C++ programs should be rebuilt to implement these
changes!

The global configuration file has a ini-file like syntax, with some
extensions to make it more flexible and to be able to correctly convert
variables to all specific configuration files. See comments there for
more information.

Configuration of the compilers of the supported languages should be
done separately. For each supported language a bash shell-script named
'compile_<lang>.sh' should be made and placed in SYSTEM_ROOT/judge,
where <lang> is the ID of the language as specified in the
database. For more information, see for example compile_c.sh and
test_solution.sh for syntax in SYSTEM_ROOT/judge.

For running solution programs under a non-privileged user, a user has
to be added to the system(s) which act as judger. This user does not
need a home-directory or password, so e.g. the following command
would suffice to add a user 'test' with minimal privileges:

useradd -d /nonexistent -g nobody -M -n -s /bin/false test

This user must also be configured as the user under which programs run
in SYSTEM_ROOT/etc/global.cfg.

TODO: installation and configuration of webserver and mysql.


SECURITY
--------

This judging system was developed with security as one of the main
goals in mind. To implement this rigourously in various aspects 
(restricting team access to others and the internet, restricting
access to the submitted programs on the jury computers, etc...)
requires root privileges to different parts of the whole contest
environment. Also, security measures might depend on the environment.
Therefor we have decided not to implement security measures which are
not directly related to the judging system itself. We do have some
suggestions on how you can setup external security.

CONSIDERATIONS

Security considerations for a programming contest are a bit different
from those in normal conditions: normally users only have to be
protected from deliberately harming eachother. During a contest we
also have to restrict users from cooperatively communicating,
accessing restricted resources (like internet) and restrict user
programs running on jury computers.

We expect that chances are small that people are trying to cheat
during a programming contest: you have to hack the system and make use
of that within very limited time. And you have to not get caught and
disqualified afterwards. Therefor passive security measures of warning
people of the consequenses and only check (or probe) things will
probably be enough.

However we wanted the system to be as secure as possible within
reason. Furthermore this software is open source, so users can try to
find weak spots before the contest.

INTERNAL SECURITY

Internal security of the system relies on users not being able to get
to any vital data (jury input/output and users' solutions). Data is
stored in two places: files on the jury account and in the SQL
database. Files should be protected by preventing permission to the
relevant directories. Database access is protected by passwords.

NOTE: database passwords are stored in SYSTEM_ROOT/etc/passwords.php.
This file has to be non-readable to teams, but has to be readable to
the webserver to let the jury webinterface work. A solution is to
make it readable to a special group the webserver runs as.

Secondly, the files submitted should not be interceptable by other
teams (even though that, if these would be sent clear-text, a team
would normally have to be root/administrator on their computer to
intercept this). By default this is accomplished by transferring these
files with ssh (and even locally on the jury-computers). See
SYSTEM_ROOT/submit/submit_copy.sh for more information.

Teams should not be able to fake the identity of another team. This is
prevented in the submission system, by making use of temporary files
in a world non-readable directory of the team account: during
submission, the file is copied there with some random part and this
file will be copied by the jury. An other team cannot guess filenames
there, so trying to send as a different team would only result in a
copying error. During submission, the IP address is also checked.
The team webinterface relies on authentication by IP address only:
this has the advantage for teams that they do not have to fill in yet
another user/password combination. Only if teams are able to spoof
their IP (for which they normally need root/administrator privileges),
then they would be able to view other teams' submission info (not their
code) and clarifications. As this gives a team little advantage, we
think that this suffices.

A difficult issue is the securing of submitted programs run by the
jury. We do not have any control over these sources and do not want to
rely on checking them manually or filtering on things like system
calls (which can be obscured and are different per language). Therefor
we decided to tackle this isssue by running these programs in a
environment as restrictive as possible. This is done by setting up a
minimal chroot environment, for which root privileges and statically
compiled programs are needed. By also limiting all kinds of system
resources (memory, processes, time, unprivileged user) we protect the
system from programs, which try to hack or could crash the system.
However, a chroot environment does not restrict network access, so
there lies a possible security risk, which has to be handled
separately.

EXTERNAL SECURITY

The following security issues are NOT handled by DOMjudge, but left to
the jury to set up.

Network traffic between team- and jury-computers and the internet
should be limited to what is allowed. Possible ways of enforcing this,
might be: monitor traffic, modify firewall rules on team computers or
(what we implemented with great satisfaction) put all team computers
behind a firewalling router.

Solutions are run within a restricted (chroot) environment on the
judge computers. This however does not restrict network access, so a
team could try to send in a solution, that tries to send input
testdata back to them, access the internet, etc... A solution to this
problem is to disallow all network traffic for the test user on the
judge computers. On linux with kernel 2.4 and higher, this can be
accomplished by modifying the iptables, by adding a rule like:

iptables -I OUTPUT -o <network_interface> -m owner --uid-owner <testuser_uid> -j REJECT



$Id$
